/**
 * Compilador D&D – versão base
 * Requisitos mínimos: declaração, atribuição, if/else, while, do-until,
 * três tipos, dois laços, controle de erros em PT-BR.
 */

options {
  STATIC = true;
  LOOKAHEAD = 2;          // garante parsing LL(k) simples
}

PARSER_BEGIN(DungeonCompilador)
package source;

public class DungeonCompilador {
  public static void main(String[] args) {
    try {
      System.out.println("Iniciando uma nova historia!");
      DungeonCompilador p = new DungeonCompilador(System.in);
      p.programa();                     // 1 compilacao
    } 
    catch (ParseException e)
    {
      System.out.println("Voce falha no teste sintatico.");
      System.out.println(e.getMessage());
    }
    catch (TokenMgrError e)
    {
      System.out.println("Voce falha no teste lexico.");
      System.out.println(e.getMessage());
    }
  }
}
PARSER_END(DungeonCompilador)

/* ------------------------------------------------------------------ */
/*  LÉXICO                                                             */
/* ------------------------------------------------------------------ */

SKIP : { " " | "\t" | "\r" | "\n" }

/* --- Palavras-chave & símbolos --- */
TOKEN :
{
      < INICIAPROG   : "campanha" >
  |   < ABREBLOCO    : "mesa" >
  |   < FECHABLOCO   : "e_eh_aqui" >
  |   < FIMINST      : "fim_de_turno" >

  |   < IF           : "rola_um_dado_ai" >
  |   < THEN         : "acerta" >
  |   < ELSE         : "erra" >
  |   < END          : "long_rest" >

  |   < WHILE        : "iniciativa" >
  |   < DO           : "sua_vez" >
  |   < UNTIL        : "vez_do_monstro" >

  /* tipos */
  |   < TIPOINT      : "forca" >
  |   < TIPOFLOAT    : "destreza" >
  |   < TIPOBOL      : "inteligencia" >
  |   < TIPOCHAR     : "sabedoria" >

  /* operadores */
  |   < ASSIGN       : "recebe" >
  |   < PLUS         : "buff" >  |   < MINUS  : "debuff" >
  |   < TIMES        : "crit" >  |   < DIV    : "partilha" >

  |   < EQ : "==" > | < NE : "!=" > | < GT : ">" > | < GE : ">=" >
  |   < LT : "<" >  | < LE : "<=" >

  |   < ANDBOOL : "&&" > | < ORBOOL : "||" > | < NOTBOOL : "!" >

  /* literais e identificadores */
  |   < INT_LIT   : (["0"-"9"])+ >
  |   < FLOAT_LIT : (["0"-"9"])+ "." (["0"-"9"])+ >
  |   < BOOL_LIT  : "verdadeiro" | "falso" >
  |   < CHAR_LIT  : "'" ~["'"] "'" >

  |   <IDENT   : <LETTER> (<LETTER> | <DIGIT>)* >
  |   <#LETTER : ["a"-"z","A"-"Z","_"] >
  |   <#DIGIT  : ["0"-"9"] >
}

/* ------------------------------------------------------------------ */
/*  SINTAXE (LL)                                                      */
/* ------------------------------------------------------------------ */

/* programa : campanha id mesa bloco e_eh_aqui fim_de_turno EOF */
void programa() :
{}
{
  try {
    <INICIAPROG> <IDENT> <ABREBLOCO>
        bloco()
    <FECHABLOCO> <FIMINST>
  } catch (ParseException e) {
    System.out.println("Erro sintático em programa(): " + e.getMessage());
    skipUntil(FIMINST);
  } 
  //<EOF>
}

/* bloco : {decl | cmd}* */
void bloco() :
{}
{
  (
    try {
      declaraVariavel() | comando()
    } catch (ParseException e) {
      System.out.println("Erro sintático em bloco(): " + e.getMessage());
      skipUntil(FIMINST, FECHABLOCO);
    }
  )*
}

void declaraVariavel() : {}
 {
   try {
     tipo() listaDeclaracoes() <FIMINST>
   } catch (ParseException e) {
     System.out.println("Erro sintático em declaraVariavel(): " + e.getMessage());
     skipUntil(FIMINST);
   }
 }
 
 void listaDeclaracoes() : {}
 {
   try {
     declaracao() ( "," declaracao() )*
   } catch (ParseException e) {
     System.out.println("Erro sintático em listaDeclaracoes(): " + e.getMessage());
     skipUntil(FIMINST);
   }
 }

 void declaracao() : {}
 {
   try {
     <IDENT> ( <ASSIGN> expressao() )?
   } catch (ParseException e) {
     System.out.println("Erro sintático em declaracao(): " + e.getMessage());
     skipUntil(FIMINST);
   }
 }
 
/* tipo : forca | destreza | inteligencia | sabedoria */
void tipo() :
{}
{
  <TIPOINT> | <TIPOFLOAT> | <TIPOBOL> | <TIPOCHAR>
}

/* ---------------- COMANDOS ---------------- */
void comando() :
{}
{
    atribuicao()
  | condicional()
  | lacoWhile()
  | lacoDoUntil()
}

/* atrib : id = expr fim_de_turno */
void atribuicao() :
{}
{
  try {
    <IDENT> <ASSIGN> expressao() <FIMINST>
  } catch (ParseException e) {
    System.out.println("Erro sintático em atribuicao(): " + e.getMessage());
    skipUntil(FIMINST);
  }
}

/* if : if (expr) entao bloco [se_nao bloco] fim */
void condicional() :
{}
{
  try {
    <IF> expressao() <THEN> bloco() ( <ELSE> bloco() )? <END>
  } catch (ParseException e) {
    System.out.println("Erro sintático em condicional(): " + e.getMessage());
    skipUntil(END);
  }
}

/* while : iniciativa (expr) sua_vez bloco fim */
void lacoWhile() :
{}
{
  try {
    <WHILE> expressao() <DO> bloco() <END>
  } catch (ParseException e) {
    System.out.println("Erro sintático em lacoWhile(): " + e.getMessage());
    skipUntil(END);
  }
}

/* do-until : sua_vez bloco vez_do_monstro (expr) fim_de_turno   */
void lacoDoUntil() :
{}
{
  try {
    <DO> bloco() <UNTIL> expressao() <FIMINST>
  } catch (ParseException e) {
    System.out.println("Erro sintático em lacoDoUntil(): " + e.getMessage());
    skipUntil(FIMINST);
  }
}

/* ---------------- EXPRESSÕES ---------------- */

/* expr lógico OR */
void expressao() : {} { 
  expAND() ( <ORBOOL> expAND() )*
}

/* expr lógico AND */
void expAND() : {} {
  expRel() ( <ANDBOOL> expRel() )*
}

/* expr relacional */
void expRel() : {} {
  expAditiva() ( (<EQ>|<NE>|<GT>|<GE>|<LT>|<LE>) expAditiva() )?
}

/* + / - */
void expAditiva() : {} {
  expMult() ( (<PLUS>|<MINUS>) expMult() )*
}

/* * / */
void expMult() : {} {
  fator() ( (<TIMES>|<DIV>) fator() )*
}

/* fator */
void fator() : {} {
      <IDENT>
    | literal()
    | <NOTBOOL> fator()
    | "(" expressao() ")"
}

/* literais */
void literal() : {} {
      <INT_LIT>
    | <FLOAT_LIT>
    | <BOOL_LIT>
    | <CHAR_LIT>
}

/* ---------------- SINCRONIZAÇÃO POR PÂNICO ---------------- */
void skipUntil(int... tokens) :
{}
{
  {
    Token t;
    outer:
    while (true) {
      t = getNextToken();
      for (int tok : tokens) {
        if (t.kind == tok) break outer;
      }
      if (t.kind == 0) break; // EOF
    }
  }
}
